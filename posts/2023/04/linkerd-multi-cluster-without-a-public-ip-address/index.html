<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Linkerd multi-cluster communication is a great feature, but using it in scenarios where one cluster does not have a public IP address can be tricky. In this article, I'll cover how I tackled this issue in my homelab. "><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://jacobcolvin.com/posts/2023/04/linkerd-multi-cluster-without-a-public-ip-address/><title>Linkerd Multi-cluster Without a Public IP Address :: Jacob Colvin — My Website
</title><link rel=stylesheet href=https://jacobcolvin.com/main.min.244183cde1a38e0b08f82c11791181288f9aac1cc9618cd6f4e9e7710c5768ba.css integrity="sha256-JEGDzeGjjgsI+CwReRGBKI+arBzJYYzW9OnncQxXaLo=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=https://jacobcolvin.com/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://jacobcolvin.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://jacobcolvin.com/favicon-16x16.png><link rel=manifest href=https://jacobcolvin.com/site.webmanifest><link rel=mask-icon href=https://jacobcolvin.com/safari-pinned-tab.svg color><link rel="shortcut icon" href=https://jacobcolvin.com/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Linkerd Multi-cluster Without a Public IP Address"><meta itemprop=description content="Linkerd multi-cluster communication is a great feature, but using it in scenarios where one cluster does not have a public IP address can be tricky. In this article, I'll cover how I tackled this issue in my homelab."><meta itemprop=datePublished content="2023-04-03T00:00:00+00:00"><meta itemprop=dateModified content="2023-04-03T00:00:00+00:00"><meta itemprop=wordCount content="2247"><meta itemprop=keywords content="Homelab,Kubernetes,K8s,Linkerd,Multi-cluster,Inlets"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linkerd Multi-cluster Without a Public IP Address"><meta name=twitter:description content="Linkerd multi-cluster communication is a great feature, but using it in scenarios where one cluster does not have a public IP address can be tricky. In this article, I'll cover how I tackled this issue in my homelab."><meta property="og:url" content="https://jacobcolvin.com/posts/2023/04/linkerd-multi-cluster-without-a-public-ip-address/"><meta property="og:site_name" content="Jacob Colvin"><meta property="og:title" content="Linkerd Multi-cluster Without a Public IP Address"><meta property="og:description" content="Linkerd multi-cluster communication is a great feature, but using it in scenarios where one cluster does not have a public IP address can be tricky. In this article, I'll cover how I tackled this issue in my homelab."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-03T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-03T00:00:00+00:00"><meta property="og:see_also" content="https://jacobcolvin.com/posts/2023/04/building-a-twin-itx-cluster/"><meta property="og:see_also" content="https://jacobcolvin.com/posts/2023/01/backups-for-k8s-and-beyond/"><meta property="article:section" content="Homelab"><meta property="article:section" content="Kubernetes"><meta property="article:section" content="K8s"><meta property="article:published_time" content="2023-04-03 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=https://jacobcolvin.com/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class="logo__text logo__pathname">$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://jacobcolvin.com/about/>About</a></li><li><a href=https://jacobcolvin.com/cv/>CV</a></li><li><a href=https://jacobcolvin.com/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
11 minutes</p></div><article><h1 class=post-title><a href=https://jacobcolvin.com/posts/2023/04/linkerd-multi-cluster-without-a-public-ip-address/>Linkerd Multi-cluster Without a Public IP Address</a></h1><div class=post-excerpt>Linkerd multi-cluster communication is a great feature, but using it in scenarios where one cluster does not have a public IP address can be tricky. In this article, I'll cover how I tackled this issue in my homelab.</div><div class=post-content><p>Recently, I&rsquo;ve set up <a href=https://github.com/linkerd/linkerd2>Linkerd</a> in my homelab, and one of
the features I was really interested in was <a href=https://linkerd.io/2.12/tasks/multicluster/>multi-cluster communication</a>.
This allows you to mirror services between clusters. Meaning, apps in one
cluster can communicate with services in another cluster, as if they were in the
same cluster.</p><p>Setting up multi-cluster communication with Linkerd is straightforward under
ideal conditions. However, it can be more challenging if one of the clusters
cannot create services of type <code>LoadBalancer</code> (with a public, or otherwise
routable IP address). This is the case for me, as I have clusters both at home
and in Hetzner, with my home Kubernetes cluster running behind NAT.</p><p>Fortunately, there are ways to work around this! In this post, I&rsquo;ll walk you
through my design and implementation process, discuss the challenges I faced,
and share the workarounds I came up with to make everything run smoothly.
Additionally, I&rsquo;ll explore some alternative options for multi-cluster
communication and potential improvements to my current setup.</p><blockquote><p>My exact and up-to-date implementation of everything in this article can be
found in my homelab repo! <a href=https://github.com/MacroPower/homelab>https://github.com/MacroPower/homelab</a></p></blockquote><h2 id=the-basics>The Basics</h2><p>One thing that was not immediately clear to me, when I was following the
<a href=https://linkerd.io/2.12/tasks/multicluster/>multi-cluster setup docs</a> for the first time, was how services
are mirrored bi-directionally between clusters. The docs give examples of how to
link a theoretical &ldquo;east&rdquo; cluster to a &ldquo;west&rdquo; cluster, which can be done via
this command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#f92672>=</span>east multicluster link --cluster-name east |
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#f92672>=</span>west apply -f -
</span></span></code></pre></div><p>However, this only allows you to mirror services from the &ldquo;east&rdquo; cluster to the
&ldquo;west&rdquo; cluster. If you want to mirror services from the &ldquo;west&rdquo; cluster to the
&ldquo;east&rdquo; cluster, you need to run this command a second time, but in the inverse
order:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#f92672>=</span>west multicluster link --cluster-name west |
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#f92672>=</span>east apply -f -
</span></span></code></pre></div><p>This means that if you want bi-directional mirroring between two clusters, each
cluster needs to have the ability to create services of type <code>LoadBalancer</code>,
with an IP address that can be reached by the other cluster.</p><p>To say it differently, any clusters acting as a source for service mirrors must
be routable from any destination clusters. If the source isn&rsquo;t routable, you
have to find a way to make it so, regardless of the networking situation on the
other cluster.</p><h2 id=the-recommended-solution>The Recommended Solution</h2><p>Linkerd&rsquo;s <a href=https://linkerd.io/2.12/tasks/multicluster/>multi-cluster docs</a> recommend looking into
<a href=https://blog.alexellis.io/ingress-for-your-local-kubernetes-cluster/>inlets</a>. The concept is very cool and also pretty simple.</p><p>Basically, in your home / non-routable cluster, you can have a client acting as
a sort of proxy to any local services. The client establishes a tunnel to a
server running somewhere accessible from the cloud / routable cluster. This
means that you should be able to just point Linkerd to the inlets server, and
from there it will be routed to the client, and then to the previously
non-routable Linkerd gateway!</p><p><img alt=diagram src=https://raw.githubusercontent.com/cubed-it/inlets/master/docs/inlets.png></p><p>However, inlets is no longer the open-source project it once was. The author
stopped maintaining the open-source version a while ago, before eventually
deleting all of the source code. Now, it&rsquo;s available for purchase as a monthly
subscription, with personal licenses starting at $20/month. For me, this is a
completely infeasible price to pay. There are still parts of the project that
are open-source, notably <a href=https://github.com/inlets/inlets-operator>inlets-operator</a>, but it spins up an
entire VPS for the tunnel, which we then have to pay for, when we already have a
perfectly good K8s cluster we could be hosting it on.</p><p>Luckily, a fork of inlets was created, <a href=https://github.com/cubed-it/inlets>cubed-it/inlets</a>. This will
allow us to manually create a client in our home / non-routable cluster, and a
server in our cloud / routable cluster. Again, very luckily, the fork adds
support for tunneling TCP ports (as opposed to HTTP), which we will need for
both Linkerd and also the K8s API server.</p><h2 id=my-implementation>My Implementation</h2><p>Conceptually, what I wanted to do was this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>┌────────────────────────────────────────┐     ┌─────────────────────────────────────────┐
</span></span><span style=display:flex><span>│             Cloud Cluster              │  │  │              Home Cluster               │
</span></span><span style=display:flex><span>│                                        │     │                                         │
</span></span><span style=display:flex><span>│ ┌───────────────┐     ┌─────────────┐  │  │  │ ┌─────────────┐      ┌─────────────┐    │
</span></span><span style=display:flex><span>│ │ Inlets Server │◀────│   Ingress   │◀─┼─────┼─│Inlets Client│──┬──▶│   Linkerd   │──┐ │
</span></span><span style=display:flex><span>│ └───────────────┘     └─────────────┘  │  │  │ └─────────────┘  │   │   Gateway   │  │ │
</span></span><span style=display:flex><span>│         ▲                              │     │                  │   └─────────────┘  │ │
</span></span><span style=display:flex><span>│         ├───────────────────┐          │  │  │                  │   ┌─────────────┐  │ │
</span></span><span style=display:flex><span>│         │                   │          │     │                  └──▶│   K8s API   │  │ │
</span></span><span style=display:flex><span>│         │                   │          │  │  │                      └─────────────┘  │ │
</span></span><span style=display:flex><span>│ ┌───────────────┐ ╔══════════════════╗ │     │                      ╔═════════════╗  │ │
</span></span><span style=display:flex><span>│ │Linkerd Service│ ║      Foobar      ║ │  │  │                      ║   Foobar    ║  │ │
</span></span><span style=display:flex><span>│ │    Mirror     │ ║      Mirror      ║─│─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─▶║   Service   ║◀─┘ │
</span></span><span style=display:flex><span>│ └───────────────┘ ╚══════════════════╝ │  │  │                      ╚═════════════╝    │
</span></span><span style=display:flex><span>│         │                   ▲          │     │                                         │
</span></span><span style=display:flex><span>│         └────────Creates────┘          │  │  │                                         │
</span></span><span style=display:flex><span>└────────────────────────────────────────┘     └─────────────────────────────────────────┘
</span></span></code></pre></div><p>In this implementation, the inlets client and server is entirely contained
within Kubernetes. This is great, because we don&rsquo;t have to pay anything extra,
and also it&rsquo;s great from a security perspective because the only thing we need
to expose outside the cluster is a single endpoint for the tunnel, which can be
done via our normal ingress.</p><p>In this section, I will walk you through my implementation for setting up a
secure tunnel between my home and cloud Kubernetes clusters using inlets. We
will be deploying inlets server and client using Helm charts I created for both
the inlets server and client, which works with <a href=https://github.com/cubed-it/inlets>cubed-it/inlets</a>,
and then addressing some of the challenges encountered with Linkerd during the
process.</p><p>First, add a new namespace in every cluster:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create namespace inlets
</span></span></code></pre></div><p>And create a secret in every cluster with the same token:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>token<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span> head -c <span style=color:#ae81ff>16</span> /dev/urandom | shasum | cut -d<span style=color:#e6db74>&#34; &#34;</span> -f1 <span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>kubectl create secret generic linkerd-tunnel-token <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --from-literal<span style=color:#f92672>=</span>token<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>token<span style=color:#e6db74>}</span>
</span></span></code></pre></div><p>In our cloud cluster, we can use the <code>inlets-server</code> chart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kustomize.config.k8s.io/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Kustomization</span>
</span></span><span style=display:flex><span><span style=color:#f92672>helmCharts</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>inlets-server</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>repo</span>: <span style=color:#ae81ff>https://jacobcolvin.com/helm-charts/</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;0.1.1&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>releaseName</span>: <span style=color:#ae81ff>linkerd-tunnel</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>inlets</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>valuesInline</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>inlets</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Port is the main port that serves any HTTP traffic.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Other TCP ports are assigned on the client.</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>4191</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>disableTransportWrapping</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>tokenSecretName</span>: <span style=color:#ae81ff>linkerd-tunnel-token</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>data-plane</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ClusterIP</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>kube</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>6443</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>proxy</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>4143</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>admin</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>port</span>: <span style=color:#ae81ff>4191</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ingress</span>: {}
</span></span><span style=display:flex><span>      <span style=color:#75715e>#  main:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#    enabled: true</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#    hosts:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#      - host: linkerd-tunnel.example.com</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#        paths:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#          - path: /</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#            pathType: Prefix</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#    tls:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#      - hosts: [linkerd-tunnel.example.com]</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#    annotations: {}</span>
</span></span></code></pre></div><p>In our home cluster, we can use the <code>inlets-client</code> chart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>kustomize.config.k8s.io/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Kustomization</span>
</span></span><span style=display:flex><span><span style=color:#f92672>helmCharts</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>inlets-client</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>repo</span>: <span style=color:#ae81ff>https://jacobcolvin.com/helm-charts/</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;0.1.2&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>releaseName</span>: <span style=color:#ae81ff>linkerd-tunnel</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>inlets</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>valuesInline</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>inlets</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># The url points to the ingress of the other cluster.</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>url</span>: <span style=color:#ae81ff>wss://linkerd-tunnel.example.com</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Since we don&#39;t want to restrict the hostnames the other cluster can</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># use, strictForwarding should be false.</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>strictForwarding</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>tokenSecretName</span>: <span style=color:#ae81ff>linkerd-tunnel-token</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Configure upstreams for Linkerd. Any traffic coming to `match` will</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># be forwarded to `target`. If the `match` value is `tcp:PORT`, the</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># server will automatically create a server listening on that port.</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>upstreams</span>:
</span></span><span style=display:flex><span>          - <span style=color:#75715e># Accessible on inlets.port / 4191.</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>target</span>: <span style=color:#ae81ff>http://linkerd-gateway.linkerd-multicluster.svc.cluster.local:4191</span>
</span></span><span style=display:flex><span>          - <span style=color:#f92672>match</span>: <span style=color:#ae81ff>tcp:6443</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>target</span>: <span style=color:#ae81ff>kubernetes.default.svc.cluster.local:443</span>
</span></span><span style=display:flex><span>          - <span style=color:#f92672>match</span>: <span style=color:#ae81ff>tcp:4143</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>target</span>: <span style=color:#ae81ff>linkerd-gateway.linkerd-multicluster.svc.cluster.local:4143</span>
</span></span></code></pre></div><p>In <em>theory</em>, you would expect to then be able to Link the clusters, just by
overriding the defaults for the gateway and API server addresses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#f92672>=</span>home multicluster link --cluster-name home <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --gateway-addresses <span style=color:#e6db74>&#34;linkerd-tunnel-data-plane.inlets.svc.cluster.local&#34;</span> --gateway-port <span style=color:#ae81ff>4143</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --api-server-address <span style=color:#e6db74>&#34;https://linkerd-tunnel-data-plane.inlets.svc.cluster.local:6443&#34;</span> |
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#f92672>=</span>cloud apply -f -
</span></span></code></pre></div><p>But this is not the case. There are multiple interactions between the normal
output of <code>linkerd multicluster link</code> and the inlets tunnel that need to be
accounted for.</p><h2 id=fixing-the-probe-gateway-service>Fixing the probe-gateway service</h2><p>First of all, the <code>linkerd multicluster link</code> command creates a <code>probe-gateway</code>
service, which points to the gateway&rsquo;s health endpoint. However, in this case,
that health endpoint is actually another Kubernetes service. Now, I&rsquo;m not
confident on exactly why this is, but this is not a configuration that works in
Kubernetes. The <code>probe-gateway</code> service will time out every time, even though
the endpoint it points to will work just fine. To work around this issue, we
need to change the <code>probe-gateway</code> service so that it&rsquo;s of type <code>ExternalName</code>,
with an <code>externalName</code> of the inlets server service.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>probe-gateway-home</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>linkerd-multicluster</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>mirror.linkerd.io/mirrored-gateway</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mirror.linkerd.io/cluster-name</span>: <span style=color:#ae81ff>home</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ExternalName</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>externalName</span>: <span style=color:#ae81ff>linkerd-tunnel-data-plane.inlets.svc.cluster.local</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mc-probe</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>4191</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span></code></pre></div><p>Once this is done, the <code>linkerd multicluster link</code> command will work, and the
<code>linkerd multicluster check</code> command will actually succeed as well. However, if
you then create a service mirror, it will not work.</p><h2 id=fixing-the-service-mirror>Fixing the service mirror</h2><p>The service mirror suffers from the same issue as the probe gateway. It creates
a service that points to the gateway&rsquo;s proxy endpoint, which is another
Kubernetes service. Unfortunately, we can&rsquo;t solve this so easily since the
service mirror is created dynamically by Linkerd. But, we can get around this
issue by changing the way that we expose the gateway&rsquo;s proxy endpoint. Instead
of using a normal service, we can create a <code>LoadBalancer</code> service, which is very
annoying, but I couldn&rsquo;t find any better workarounds for it. Note that this
service does not need to be exposed outside the cluster, so don&rsquo;t feel a need to
add a firewall exception or anything like that.</p><p>This introduces an additional issue. If we already have a <code>LoadBalancer</code> in our
cluster for the gateway (for services being mirrored in the other direction),
we can&rsquo;t reuse the same port.</p><p>You can implement all of this by first making a slight modification to the
upstreams declared in the <code>inlets-client</code> chart, to remap the ports:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>upstreams</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>target</span>: <span style=color:#ae81ff>http://linkerd-gateway.linkerd-multicluster.svc.cluster.local:4191</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>match</span>: <span style=color:#ae81ff>tcp:6443</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>target</span>: <span style=color:#ae81ff>kubernetes.default.svc.cluster.local:443</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>match</span>: <span style=color:#ae81ff>tcp:6143</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>target</span>: <span style=color:#ae81ff>linkerd-gateway.linkerd-multicluster.svc.cluster.local:4143</span>
</span></span></code></pre></div><p>And also changing the services declared in the <code>inlets-server</code> chart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>inlets</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>6191</span>
</span></span><span style=display:flex><span><span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>data-plane</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ClusterIP</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>kube</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>6443</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>admin</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>6191</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>data-plane-lb</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>type</span>: <span style=color:#ae81ff>LoadBalancer</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add any annotations you need, e.g. for MetalLB.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>annotations</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>proxy</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>6143</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span></code></pre></div><p>And the <code>probe-gateway</code> service that we changed, we need to change it again for
the new <code>mc-probe</code> port:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>probe-gateway-home</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>linkerd-multicluster</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>mirror.linkerd.io/mirrored-gateway</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mirror.linkerd.io/cluster-name</span>: <span style=color:#ae81ff>home</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ExternalName</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>externalName</span>: <span style=color:#ae81ff>linkerd-tunnel-data-plane.inlets.svc.cluster.local</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mc-probe</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>6191</span> <span style=color:#75715e># &lt;-- The new port.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span></code></pre></div><h2 id=meshing-the-inlets-pods>Meshing the inlets pods</h2><p>As a bit of a plus, using different ports from <code>linkerd-proxy</code> means that we can
mesh the inlets pods themselves. You can do this by adding <code>linkerd.io/inject: enabled</code> to the namespace annotations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Namespace</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>inlets</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>linkerd.io/inject</span>: <span style=color:#ae81ff>enabled</span>
</span></span></code></pre></div><p>The only change you will need to make is on the client. You will also need to
skip the Linkerd outbound ports, which you can do by adding the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>podAnnotations</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>config.linkerd.io/skip-outbound-ports</span>: <span style=color:#e6db74>&#34;4143,4191&#34;</span>
</span></span></code></pre></div><h2 id=linking-the-clusters>Linking the clusters</h2><p>With all these workarounds in place, the architecture looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>┌──────────────────────────────────────────────────────────┐     ┌─────────────────────────────────────┐
</span></span><span style=display:flex><span>│                      Cloud Cluster                       │  │  │            Home Cluster             │
</span></span><span style=display:flex><span>│                                                          │     │                                     │
</span></span><span style=display:flex><span>│ ┌───────────────┐   ┌───────────────┐   ┌─────────────┐  │  │  │ ┌───────────────┐   ┌─────────────┐ │
</span></span><span style=display:flex><span>│ │ Inlets Server │◀──│ Service: 8123 │◀──│   Ingress   │◀─┼─────┼─│ Inlets Client │──▶│   K8s API   │ │
</span></span><span style=display:flex><span>│ └───────────────┘   └───────────────┘   └─────────────┘  │  │  │ └───────────────┘   └─────────────┘ │
</span></span><span style=display:flex><span>│         ▲                                                │     │         │                           │
</span></span><span style=display:flex><span>│         ├─────────────────┬───────────────────┐          │  │  │         │                           │
</span></span><span style=display:flex><span>│         │                 │                   │          │     │         │                           │
</span></span><span style=display:flex><span>│ ┌───────────────┐ ┌───────────────┐ ┌──────────────────┐ │  │  │         │                           │
</span></span><span style=display:flex><span>│ │    K8s API    │ │Gateway Health │ │  Gateway Proxy   │ │     │         └──────────────────┐        │
</span></span><span style=display:flex><span>│ │ Service: 6443 │ │ Service: 6191 │ │ Private LB: 6143 │ │  │  │                            │        │
</span></span><span style=display:flex><span>│ └───────────────┘ └───────────────┘ └──────────────────┘ │     │                            │        │
</span></span><span style=display:flex><span>│         ▲                 ▲                   ▲          │  │  │                            │        │
</span></span><span style=display:flex><span>│         │                 │                   │          │     │                            ▼        │
</span></span><span style=display:flex><span>│ ┌───────────────┐  ┌─────────────┐  ╔══════════════════╗ │  │  │  ╔═════════════╗    ┌─────────────┐ │
</span></span><span style=display:flex><span>│ │Linkerd Service│  │probe-gateway│  ║      Foobar      ║ │     │  ║   Foobar    ║    │   Linkerd   │ │
</span></span><span style=display:flex><span>│ │    Mirror     │─▶│ExternalName │  ║      Mirror      ║─│─ ┼ ─│─▶║   Service   ║◀───│   Gateway   │ │
</span></span><span style=display:flex><span>│ └───────────────┘  └─────────────┘  ╚══════════════════╝ │     │  ╚═════════════╝    └─────────────┘ │
</span></span><span style=display:flex><span>│                                                          │  │  │                                     │
</span></span><span style=display:flex><span>└──────────────────────────────────────────────────────────┘     └─────────────────────────────────────┘
</span></span></code></pre></div><p>Now we can link the two clusters (but for real this time):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#f92672>=</span>home multicluster link --cluster-name home <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --gateway-addresses <span style=color:#e6db74>&#34;&lt;The address of your LoadBalancer&gt;&#34;</span> --gateway-port <span style=color:#ae81ff>6143</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --api-server-address <span style=color:#e6db74>&#34;https://linkerd-tunnel-data-plane.inlets.svc.cluster.local:6443&#34;</span> |
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#f92672>=</span>cloud apply -f -
</span></span></code></pre></div><h2 id=other-options>Other Options</h2><p>There are tons of other avenues that could be explored for this. I went down
this particular path because it was recommended in the Linkerd docs. However,
basically any solution that would allow our cloud cluster to talk directly to
our homelab would have worked. For example, setting up something like Wireguard
would also have probably been a very reasonable solution.</p><p>There are also other options for multi-cluster communication, besides Linkerd.
However, I believe they will all have the same or worse networking requirements.
For example, some solutions require that all individual nodes be routable across
all clusters.</p><h2 id=future-work>Future Work</h2><ul><li><p>I don&rsquo;t think there&rsquo;s any reason why a K8s provisioner couldn&rsquo;t be added to
<a href=https://github.com/inlets/inlets-operator>inlets-operator</a>, which means we wouldn&rsquo;t have to use the
forked version of inlets.</p></li><li><p>There may also be a way to modify the service mirrors created by
<a href=https://github.com/linkerd/linkerd2>Linkerd</a>, such that they can be directly routed through the tunnel,
instead of having to hit a LoadBalancer first, e.g. by creating them as type
<code>ExternalName</code>.</p></li></ul><h2 id=conclusion>Conclusion</h2><p>I hope this was helpful. To learn more, you can check out the following links:</p><ul><li>Linkerd: <a href=https://github.com/linkerd/linkerd2>https://github.com/linkerd/linkerd2</a></li><li>Linkerd Multi-Cluster: <a href=https://linkerd.io/2.12/tasks/multicluster/>https://linkerd.io/2.12/tasks/multicluster/</a></li><li>Inlets: <a href=https://blog.alexellis.io/ingress-for-your-local-kubernetes-cluster/>https://blog.alexellis.io/ingress-for-your-local-kubernetes-cluster/</a></li><li>Inlets Operator: <a href=https://github.com/inlets/inlets-operator>https://github.com/inlets/inlets-operator</a></li><li>Inlets Fork by cubed-it: <a href=https://github.com/cubed-it/inlets>https://github.com/cubed-it/inlets</a></li></ul><p>And finally, again, if you would like to see my exact and up-to-date
implementation of everything above, check out my homelab repo:</p><ul><li><a href=https://github.com/MacroPower/homelab>https://github.com/MacroPower/homelab</a></li></ul><p> </p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://jacobcolvin.com/categories/homelab/>Homelab</a></span>
<span class=tag><a href=https://jacobcolvin.com/categories/kubernetes/>Kubernetes</a></span>
<span class=tag><a href=https://jacobcolvin.com/categories/k8s/>K8s</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
2247 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-04-03 00:00</p></div><div class=pagination><div class=pagination__buttons><span class="button next"><a href=https://jacobcolvin.com/posts/2023/04/building-a-twin-itx-cluster/><span class=button__text>Building a Twin-ITX Cluster</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2024</span>
<span><a href=https://jacobcolvin.com/>Jacob Colvin</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://jacobcolvin.com/posts/index.xml target=_blank title=rss><svg width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Made with <a href=http://gohugo.io>Hugo</a> + <a href=https://github.com/rhazdon/hugo-theme-hello-friend-ng>Hello Friend NG</a></span><span>Hosted on <a href=https://github.com/MacroPower/macropower.github.io>Pages</a></span></div></div></footer></div><script type=text/javascript src=https://jacobcolvin.com/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>